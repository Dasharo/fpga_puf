# :closed_lock_with_key: A Physical Unclonable Function for _any_ FPGA

[![license](https://img.shields.io/github/license/stnolting/fpga_puf?longCache=true&style=flat-square)](https://github.com/stnolting/fpga_puf/blob/main/LICENSE)

* [Introduction](#Introduction)
* [Theory of Operation](#Theory-of-Operation)
   * [Post-Processing](#Post-Processing)
* [Top Entity](#Top-Entity)
* [Evaluation](#Evaluation)
   * [Setup](#Setup)
   * [ID Results](#ID-Results)
   * [Hardware Utilization](#Hardware-Utilization)
   * [Summary](#Summary)


## Introduction

A physical unclonable function (PUF) provides a digital _fingerprint_ that can be used as **unique identifier** for
security-related applications. The `fpga_puf` hardware module provides an unclonable 96-bit unique identifier (ID)
that is defined by the target chip's semiconductor characteristics. It is implemented in a technology-independent
way that does not use any device-specific macros, primitives or attributes so it can be implemented on _any_ FPGA.

:key: The PUF ID is _unique_ for the combination of bitstream and _one_ specific FPGA. The same bitstream
will lead to a different PUF ID on a different FPGA of same type. If the bitstream of a specific FPGA is changed
(by changing design logic) the PUF ID of that specific FPGA will also change.

**Key features**

* [x] technology-, vendor- and platform-agnostic implementation
* [x] easy to use
* [x] tiny hardware footprint (less than 200 LUTs)
* [x] secure and reliable

:loudspeaker: This is an ongoing research / proof-of-concept project. Feedback from the community is highly appreciated
(see notes in section ["Summary"](#Summary))!


## Theory of Operation

Each bit of the 96-bit PUF ID is generated by an individual **PUF cell**. Each cell consists of an asynchronous element that is
based on a simple ring oscillator. The oscillator is constructed from a single inverter that negates it's own output signal.
This feedback loop is interrupted by a latch. If the latch is open (=transparent) the oscillator starts oscillating.
If the latch is closed, it stores the last state of the oscillator (high or low). The latch also provides a reset
to bring each cell into a defined state.

The frequency of each oscillator is defined by the mapping of the logic cell and the according routing. Both factors
are constant for a specific bitstream. Furthermore, the frequency is also randomly (but constantly for a given setup)
"tuned" by the chip's semiconductor characteristics.
These are caused by tiny productions fluctuation (for example the capacitance / delay of a routing wire is affected
by variation in oxide thickness). The frequency of each oscillator is considered to be fixed. Hence, sampling several periods
within a fixed time window will always end in the same state (oscillator output is high or low). Temperature drift
disturbs all oscillators in the (nearly) same way and has to be computationally eliminated/compensated by the
[post-processing](#Post-Processing).

Since `fpga_puf` does not use any device-specific attributes or primitives, there is a risk that the synthesis toolchain will
remove the asynchronous PUF cells or collapse them into a single PUF cell ("optimize away"). Therefore, the design
uses a shift register to control reset and the latch open/close phase of each cell individually and distributed over time. This concept is
based on the [NEORV32 TRNG](https://github.com/stnolting/neorv32) and allows a **platform-independent implementation**.

Whenever a new sampling of the PUF ID is started, a 96+1 bit wide shift register. A single '1' is applied to the
least significant bit that travels throughout the whole shift register chain during operation. The PUF cell's control signals (reset and
latch control) are connected to this shift register. Each shift register bit `i` controls the reset of PUF cell
`i` and the latch control of PUF cell `i+1`. Thus, a cell's reset is active for one clock cycle. In the next clock
cycle the cell's latch is opened for exactly one clock cycle allowing the oscillator to run. In the next clock cycle
the latch is closed again and has captured the oscillator's last state.

When the single one-bit reaches the most significant bit (bit 96) of the shift register the sampling process is
completed and the latch states are sampled into a register that provides the obtained _raw_ PUF ID.

The following figure is taken from the Intel Quartus Prime technology viewer showing a single PUF cell (cell #44).
The oscillator as well as the latch are mapped to a single LUT3 element in the FPGA. The output of this asynchronous
element is sampled by a simple register. Hence, a single PUF cell only requires one LUT and one FF.

(`DATAA` is the latch reset (high-active), `DATAC` is the latch control (open when set), `DATAD` is the
feedback of the inverter)

![puf_cell](https://raw.githubusercontent.com/stnolting/fpga_puf/main/img/intel_technology_cell.png)

### Post-Processing

Some bits of the _raw_ PUF ID might be quite noisy, which complicates defining a _stable_ ID that does not
change over time and over a broad range of operation conditions (e.g. temperature). A lot(!) of different
approaches can be found in literatures. One promising approach is the use of error-correction codes to "stabilizes"
an initially determined ID.

However, these concepts are out of (my) scope so I used a simple "averaging" concept for this example. My approach samples
the _raw_ PUF ID several times (for example 4096 times) and checks how often each bit of the ID is set across
all sampled IDs. If an ID bit is set in more then half of the samples it is considered to be a static `1`, otherwise it is considered to
be a static `0`. Since a few bits of the raw ID might be quite noisy, a hysteresis is used to eliminate those bits from the final PUF:
if a bit is set or cleared more often than a certain _threshold_ it is considered "stable" in the final ID. These lower and
upper hysteresis threshold define an _uncertain_ band between them. For the final ID all bits tha fall
into this uncertainty band are masked to be always zero.

My post-processing concept can be found in [`sw/main.c`](https://github.com/stnolting/fpga_puf/blob/main/sw/main.c). The
source file provids more-detailed comments.


## Top Entity

The top entity of the PUF IP module is `fpga_puf` ([`rtl/fpga_puf.vhd`](https://github.com/stnolting/fpga_puf/blob/main/rtl/fpga_puf.vhd)).
It can be directly instantiated without the need for any special libraries.

```vhdl
entity fpga_puf is
  port (
    clk_i  : in  std_ulogic; -- global clock line
    rstn_i : in  std_ulogic; -- SYNC reset, low-active
    trig_i : in  std_ulogic; -- set high for one clock to trigger ID sampling
    busy_o : out std_ulogic; -- busy when set (sampling ID)
    id_o   : out std_ulogic_vector(95 downto 0) -- PUF ID (valid after sampling is done)
  );
end fpga_puf;
);
```

:warning: Note that the PUF cannot be simulated due to it's combinatorial loops.

## Evaluation

To evaluate this concept and the quality/reliability of the PUF IDs I am using the [NEORV32](https://github.com/stnolting/neorv32)
as processor platform. The `fpga_puf` IP module is added to the processor's "Custom Functions Subsystem (CFS)",
which is a _blank_ template for implementing custom application-specific co-processors.

The setup is synthesized for different FPGAs using different toolchains (like Intel and Lattice). A specific
bitstream generated and programmed into _several_ FPGAs of the _same_ type to check for chip-specific
ID variations. On one chip the ID is generated several times to check if it is "stable over time" and thus, reliable.

### Setup

The application-specific PUF-wrapping CFS can be found in
[`rtl/neorv32_cfs.vhd`](https://github.com/stnolting/fpga_puf/blob/main/rtl/neorv32_cfs.vhd). Make sure to use this
CFS file instead of the default NEORV32 CFS source file when reproducing this setup.

The CFS uses four memory-mapped registers to interface the PUF ID module:

| CSF register address (_C_ access macro) | Access | Function          |
|:----------------------------------------|:------:|:------------------|
| `NEORV32_CFS.REG[0]`                    |  `r/w` | Control register  |
| `NEORV32_CFS.REG[1]`                    |  `r/-` | PUF ID bits 31:0  |
| `NEORV32_CFS.REG[2]`                    |  `r/-` | PUF ID bits 63:32 |
| `NEORV32_CFS.REG[3]`                    |  `r/-` | PUF ID bits 95:64 |

Bit _0_ of the control register (`PUF_CTRL_EN`) control the synchronous reset signal of the `fpga_puf` module
(`rstn_i`). Setting this bit will activate the module, clearing it will put the module into reset state.

Bit _1_ of the control register (`PUF_CTRL_SAMPLE`) is used to start the sampling of the ID. Writing one to it
will set the trigger signal (`trig_i`) high for one cycle. Reading this control register bit will return
the busy state of the `fpga_puf` module (`busy_o`).

:floppy_disk: The low-level hardware-accessing functions are implemented in
[`sw/fpga_puf_neorv32_cfs.c`](https://github.com/stnolting/fpga_puf/blob/main/sw/fpga_puf_neorv32_cfs.c). The header file
[`sw/fpga_puf_neorv32_cfs.h`](https://github.com/stnolting/fpga_puf/blob/main/sw/fpga_puf_neorv32_cfs.h)
provides the function prototypes, a PUF ID data type and also the NEORV32 CFS register mappings and bit definitions.

The PUF test program ([`sw/main.c`](https://github.com/stnolting/fpga_puf/blob/main/sw/main.c)) is used to sample
the chip's PUF ID and transmit it via UART to a terminal program:

```
Physical Unclonable Functions <fpga_puf> Test
PUF implemented as NEORV32 Custom Functions Subsystem (CFS)

Press any key to start PUF test (8 runs with 4096 samples each).
Starting test...
Run 0 ID: 0x37c0480063021011988c0095
Run 1 ID: 0x37c0480063021011988c0095
Run 2 ID: 0x37c0480063021011988c0095
Run 3 ID: 0x37c0480063021011988c0095
Run 4 ID: 0x37c0480063021011988c0095
Run 5 ID: 0x37c0480063021011988c0095
Run 6 ID: 0x37c0480063021011988c0095
Run 7 ID: 0x37c0480063021011988c0095
Test completed.
```

### ID Results

So far I have tested the PUF module on three Lattice iCE40 UltraPlus FPGAs and four Intel Cyclone IV FPGAs
(shout-out to [@emb4fun](https://github.com/emb4fun) - thank you for your help!). The ID was generated 8 times
on each chip to "check" if it is reproducible (drawback: just in a very short time window...).

| FPGA                            | PUF ID ("Fingerprint Key")   |
|:--------------------------------|:-----------------------------|
| Lattice iCE40 UltraPlus - **1** | `0x37c0480063021011988c0095` |
| Lattice iCE40 UltraPlus - **2** | `0x592063e50118040c2000112b` |
| Lattice iCE40 UltraPlus - **3** | `0x941c82505112323600b0c221` |
| Intel Cyclone IV - **1**        | `0x9fbe33dc9021be3156cae31b` |
| Intel Cyclone IV - **2**        | `0xa726db495a2a8346b30f2000` |
| Intel Cyclone IV - **3**        | `0x413fe25557311be7f9f5edfb` |
| Intel Cyclone IV - **4**        | `0xca8ee8dc7945fa60f770e1fa` |


### Hardware Utilization

Mapping results for the custom function subsystem (CFS), the `fpga_puf` module and a single PUF cell.

| Lattice ice40 UltraPlus `iCE40UP5K-SG48I` @24MHz           | Logic Cells | Logic Registers |
|:-----------------------------------------------------------|------------:|----------------:|
| neorv32_cfs_inst_true.neorv32_cfs_inst                     |    171 (71) |        232 (35) |
| -fpga_puf_inst                                             |     100 (4) |       197 (101) |
| --fpga_puf_cell_inst[0].fpga_puf_cell_inst_i               |       1 (1) |           1 (1) |

| Intel Cyclone IV `EP4CE22F17C6N` @100MHz                   | Logic Cells | Logic Registers |
|:-----------------------------------------------------------|------------:|----------------:|
| neorv32_cfs:\neorv32_cfs_inst_true:neorv32_cfs_inst        |    241 (43) |        232 (35) |
| -fpga_puf:fpga_puf_inst                                    |   198 (102) |       197 (101) |
| --fpga_puf_cell:\fpga_puf_cell_inst:0:fpga_puf_cell_inst_i |       1 (1) |           1 (1) |


### Summary

The PUF IDs are unique for each FPGA and are reproducible. However, I did not test the PUF over
a very long time (days? "aging?") and different environment conditions (temperature?) yet. On some FPGAs
the ID shows single-bit flips over time in one or two bits. A better post-processing algorithm
should be able to compensate that.

:loudspeaker: If you have any ideas how to improve reliability feel free to open a new
[issue](https://github.com/stnolting/fpga_puf/issues). I also happy to get more data, so if you
have ported the design on another FPGA you can open a [pull request](https://github.com/stnolting/fpga_puf/pulls)
and add your data.
